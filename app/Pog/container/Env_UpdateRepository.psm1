using module ..\Utils.psm1
. $PSScriptRoot\..\header.ps1

# Pog.dll should be already loaded as an assembly, re-import it to access the cmdlets
# it is imported inside this module so that we can control what we expose to the package
Import-Module ([Pog.InternalState].Assembly.Location)

# always use basic parsing inside the generators, to ease compatibility with PowerShell 5
$global:PSDefaultParameterValues["Invoke-WebRequest:UseBasicParsing"] = $true
$global:PSDefaultParameterValues["Invoke-RestMethod:UseBasicParsing"] = $true

$ContainerModule = New-ContainerModule

# by default, the container module does not see global $PSDefaultParameterValues, probably because pwsh automatically
#  creates a module-scoped variable
& $ContainerModule {
	$script:PSDefaultParameterValues = $global:PSDefaultParameterValues
}

function ListVersions($Package, $ExistingVersionSet) {
	try {
		return & $ContainerModule $Package.Generator.ListVersionsSb $ExistingVersionSet
	} catch {
		throw [Exception]::new("Manifest generator for package '$($Package.PackageName)' failed while listing versions: $_", $_.Exception)
	}
}

<# Retrieve all existing versions of a package by calling the package version generator script. #>
function RetrievePackageVersions($Package, $ExistingVersionSet) {
	foreach ($Obj in ListVersions $Package $ExistingVersionSet) {
		$Version = if ($Obj -is [string] -or $Obj -is [Pog.PackageVersion]) {
			$Obj
		} else {
			try {$Obj.Version} catch {
				throw "Version generator for package '$($Package.PackageName)' returned a custom object without a Version property: $Obj"
			}
		}

		$Version = if ($Version -is [Pog.PackageVersion]) {
			$Version
		} elseif ($Version) {
			[Pog.PackageVersion]$Version
		} else {
			throw "Empty package version generated by the version generator for package '$($Package.PackageName)'."
		}

		[pscustomobject]@{
			Version = $Version
			# store the original value, so that we can pass it unchanged to the manifest generator
			OriginalValue = $Obj
		}
	}
}

# FIXME: if -Force is passed, track if there are any leftover manifests (for removed versions) and delete them after prompting
function __main {
	### .SYNOPSIS
	### This function is invoked when the ManifestGenerator container is started from `Update-PogRepository`.
	### Internally, it invokes `ListVersions` for the generator and then invokes `Generate` for each version
	### that should be regenerated.
	param(
		[Pog.LocalRepositoryVersionedPackage]$Package,
		[string[]]$Version,
		[bool]$Force,
		[bool]$ListOnly
	)

	# list available versions without existing manifest (unless -Force is set, then all versions are listed)
	# only generate manifests for versions that don't already exist, unless -Force is passed
	$ExistingVersions = [System.Collections.Generic.HashSet[string]]::new($Package.EnumerateVersionStrings())
	$GeneratedVersions = RetrievePackageVersions $Package $ExistingVersions `
		<# if -Force was not passed, filter out versions with already existing manifest #> `
		| ? {$Force -or -not $ExistingVersions.Contains($_.Version)} `
		<# if $Version was passed, filter out the versions; as the versions generated by the script
		   may have other metadata, we cannot use the versions passed in $Version directly #> `
		| ? {-not $Version -or $_.Version -in $Version}

	if ($Version -and @($Version).Count -ne @($GeneratedVersions).Count) {
		$FoundVersions = $GeneratedVersions | % {$_.Version}
		$MissingVersionsStr = ($Version | ? {$_ -notin $FoundVersions}) -join ", "
		throw "Some of the package versions passed in -Version were not found for package '$($Package.PackageName)': $MissingVersionsStr " +`
			"(Are you sure these versions exist?)"
		return
	}

	if ($ListOnly) {
		# useful for testing if all expected versions are retrieved
		return $GeneratedVersions | % {$Package.GetVersionPackage($_.Version, $false)}
	}

	$TemplateKeys = [Pog.ManifestTemplateFile]::GetTemplateKeys($Package.TemplatePath)

	# generate manifest for each version
	foreach ($v in $GeneratedVersions) {
		$p = $Package.GetVersionPackage($v.Version, $false)

		try {
			$TemplateData = if ($Package.Generator.GenerateSb) {
				$Sb = $ContainerModule.NewBoundScriptBlock($Package.Generator.GenerateSb)
				# pass the value both as $_ and as a parameter, the scriptblock can accept whichever one is more convenient
				Invoke-DollarUnder $Sb $v.OriginalValue $v.OriginalValue
			} else {
				$v.OriginalValue # if no Generate block exists, forward the value emitted by ListVersions
			}
		} catch {
			throw [Exception]::new("Manifest generator for package '$($p.PackageName)', version '$($p.Version)' failed: $_", $_.Exception)
		}

		$Count = @($TemplateData).Count
		if ($Count -ne 1) {
			throw "Manifest generator for package '$($p.PackageName)' generated " +`
				"$(if ($Count -eq 0) {"no output"} else {"multiple values"}) for version '$($p.Version)', expected a single [Hashtable]."
		}

		# unwrap the collection
		$TemplateData = @($TemplateData)[0]

		if ($TemplateData -isnot [Hashtable] -and $TemplateData -isnot [System.Collections.Specialized.OrderedDictionary]) {
			$Type = if ($TemplateData) {$TemplateData.GetType().ToString()} else {"null"}
			throw "Manifest generator for package '$($p.PackageName)' did not generate a [Hashtable] for version '$($p.Version)', got '$Type'."
		}

		if (Compare-Object $TemplateKeys ([string[]]$TemplateData.Keys)) {
			throw "Keys of the generated manifest for version '$($v.Version)' do not match the template:`n" +`
				"    Template keys: $($TemplateKeys -join ", ")`n" +`
				"    Generated manifest keys: $($TemplateData.Keys -join ", ")"
		}

		# write out the manifest
		[Pog.ManifestTemplateFile]::SerializeSubstitutionFile($p.ManifestPath, $TemplateData)

		# manifest is not loaded yet, no need to reload
		echo $p
	}
}

function Get-GithubAssetHash {
	### .SYNOPSIS
	### If `$ChecksumAsset` is not null, lookup the hash in the checksum file, otherwise download
	### the asset and compute the hash locally. This cmdlet is primarily intended for repositories
	### that provide a checksum file for some releases but not others.
	[CmdletBinding()]
	param(
			# accept an array, because `.Asset` is strongly typed as array and PowerShell
			#  does not bind a singleton array to a scalar parameter for some reason
			[Parameter(Mandatory)]
			[ValidateCount(1, 1)]
			[Pog.Utils.GitHub.GitHubAsset[]]
		$Asset,
			[ValidateCount(0, 1)]
			[Pog.Utils.GitHub.GitHubAsset[]]
		$ChecksumAsset
	)

	begin {
		if ($ChecksumAsset) {
			return Get-HashFromChecksumFile $ChecksumAsset.Url $Asset.Name
		} else {
			# TODO: also print package name and version here
			Write-Information "Computing hash locally due to a missing checksum file..."
			Get-UrlHash $Asset.Url
		}
	}
}

function Get-HashFromChecksumText {
	### .SYNOPSIS
	### Parses `$Text` as a shasum-like checksum file and returns the hash for `$FileName`/`$Pattern`.
	[CmdletBinding(DefaultParameterSetName="FileName", PositionalBinding=$false)]
	param(
			[Parameter(Mandatory, Position=0)]
			[string]
		$Text,
			[Parameter(Mandatory, Position=1, ParameterSetName="FileName")]
			[string]
		$FileName,
			[Parameter(Mandatory, ParameterSetName="Pattern")]
			[string]
		$Pattern
	)

	begin {
		if ($FileName) {
			$Pattern = [regex]::Escape($FileName)
		}

		# regex matches the almost-standard format generated by md5sum and sha*sum
		if ($Text -notmatch "(?:^|\n)([a-z0-9]+) +$Pattern(?:$|\r?\n)") {
			throw "Could not find the hash for $(if ($FileName) {"file '$FileName'"} else {"pattern '$Pattern'"}) in the passed checksum text:`n$Text"
		} else {
			return $Matches[1].ToUpperInvariant()
		}
	}
}

# FIXME: shouldn't this be called something like Get-HashFromChecksumUrl?
function Get-HashFromChecksumFile {
	### .SYNOPSIS
	### Retrieves `$Uri`, parses the text as a shasum-like checksum file and retrieves the hash for `$FileName` or `$Pattern`.
	[CmdletBinding(DefaultParameterSetName="FileName", PositionalBinding=$false)]
	param(
			[Parameter(Mandatory, Position=0)]
			[uri]
		$Uri,
			[Parameter(Mandatory, Position=1, ParameterSetName="FileName")]
			[string]
		$FileName,
			[Parameter(Mandatory, ParameterSetName="Pattern")]
			[string]
		$Pattern
	)

	begin {
		$Arg = @{}
		if ($FileName) {$Arg.FileName = $FileName}
		else {$Arg.Pattern = $Pattern}

		return Get-HashFromChecksumText (Invoke-WebRequest $Uri) @Arg
	}
}

function Get-NugetRelease {
	### .SYNOPSIS
	### Lists all versions of a Nuget package.
	[CmdletBinding(PositionalBinding=$false)]
	param(
			### Name of the Nuget package to retrieve releases for.
			[Parameter(Mandatory, Position=0)]
			[string]
		$PackageName,
			### Nuget feed URL to use. Defaults to the nuget.org feed.
			### Must be a v3 Nuget feed, v2 is not supported.
			[uri]
		$Feed = "https://api.nuget.org/v3/index.json",
			[switch]
		$IncludeUnlisted
	)

	begin {
		# good explanation: https://emgarten.com/posts/understanding-nuget-v3-feeds
		$FeedIndex = Invoke-RestMethod $Feed
		$PackageMetaUri = $FeedIndex.resources | ? "@type" -eq "RegistrationsBaseUrl" | % "@id"
		$pn = $PackageName.ToLowerInvariant()

		# e.g. https://api.nuget.org/v3/registration5-semver1/nuget.protocol/index.json
		$PackageMeta = Invoke-RestMethod "$PackageMetaUri$pn/index.json"

		# FIXME: it is likely that the feed uses pagination for packages with many releases, figure out how it works

		# skip unlisted releases (this is why need metadata, otherwise we could just directly list all package versions)
		$PackageMeta.items.items | ? {$IncludeUnlisted -or $_.catalogEntry.listed} | % {
			# would be nice to also get the hash, but Nuget only provides sha-512, while we want sha-256
			[pscustomobject]@{
				VersionStr = $_.catalogEntry.version
				Version = [Pog.PackageVersion]$_.catalogEntry.version
				Url = $_.packageContent
			}
		}
	}
}


Export-ModuleMember `
	-Cmdlet Get-UrlHash, Get-GithubRelease, Get-GithubAsset `
	-Function __main, Get-GithubAssetHash, Get-HashFromChecksumText, Get-HashFromChecksumFile, Get-NugetRelease