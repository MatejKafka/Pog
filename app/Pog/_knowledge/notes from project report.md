- in the thesis, add a section explaining to application authors how to make the life of a Pog packager easy (or in general, how to make applications portable).

- how does the packaging experience differ on Windows and Linux for the developer?
  - Linux, non-Nix
    - almost always requires sudo
    - no GUI, no user interaction
    - if different component sets are desirable, they're implemented as multiple packages (pkg, pkg-extra, pkg-tools,...)
    - unified interface, both for devs and users
    - package is built for a single package manager
    - supports dependency resolution and dynamic installation of dependencies
    - in most package managers, user provides a build script (e.g. PKGBUILD for pacman), which is executed in a build environment, downloads resources and creates a static archive, which is typically done once before the package is distributed; repositories then contain the static package containing a static archive and a metadata file; during actual package installation, the archive is just extracted over `/`
    - typically 2 separate build scripts – distro-independent install (`make install`), where files are installed into systemwide locations, and package-manager-specific install script, which typically invokes `make install` and then only does small modifications; afaik, not much standard tooling is provided by the package manager
    - more opinionated – directory structure, dependency handling,...
      - requires better support from the system (e.g. it's not possible to update existing files, so all tooling must support file-per-package)

  - Linux, Nix
    - declarative, functional
    - all dependencies must be explicitly specified
    - customized compiler, customized paths, very intrusive, especially binary packages tend to require a lot of patching
    - specialized language, hard to understand for a newcomer
    - quite inscrutable, basic usecases work similarly to other package managers (but theres more edgecases and weird errors), more complex usecases are cool, but hard to understand and use properly
    - not distro-dependent

  - Windows, Inno Setup & NSIS
    - https://heiswayi.nrird.com/get-started-with-inno-setup
    - typically requires administrator rights
    - has to configure GUI for the installer
    - can prompt the user interactively for options
      - start menu shortcuts, components, desktop,...
    - added branding
    - extensive scripting capabilities
    - does not have any assumptions about the target system (dependencies, installed software, package manager,...)
    - has to handle a lot of stuff manually (low level registry setup (file associations,...), shortcuts, dependencies, uninstallation of previous version,...)
    - unopiniated, lets you do anything you want to
    - no attempts to guarantee idempotency, or make it the default
    - need to write a custom uninstaller
  - Windows, MSI
    - https://www.firegiant.com/wix/tutorial/
    - declarative, automatic uninstallation
      - => idempotent
    - very verbose, even through Wix (industry standard way to create MSIs)
    - restrictive due to the declarative nature
    - good system integration, automatic uninstallation
    - robust against crashes, power loss,... (Tx NTFS)